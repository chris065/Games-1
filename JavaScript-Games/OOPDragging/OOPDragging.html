<!doctype html>
<html>

<head>
    <script>
        window.addEventListener("load", main, false);

        function Tile(text, posX, posY, size) {
            this.initalX = posX;
            this.initalY = posY;
            this.x = posX;
            this.y = posY;
            this.color = "rgb(230, 230, 230)"; // default gray
            this.radius = size / 2;
            this.text = text;
            this.fontSize = +(0.75 * size);
            this.fontFamiliy = "Calibri";
            this.fontColor = 'rgb(35, 35, 35)';
            this.font = "bold " + this.fontSize + "px " + this.fontFamiliy;
        }

         // Checks if the coordinates supplied are inside the tile
        Tile.prototype.isNear = function (clickX, clickY) {
            return ((clickX > this.x - this.radius) && (clickX < this.x + this.radius) && (clickY > this.y - this.radius) && (clickY < this.y + this.radius));
        };

        Tile.prototype.draw = function (context) {
            context.fillStyle = this.color;
            context.fillRect(this.x - this.radius, this.y - this.radius, 2 * this.radius, 2 * this.radius);

            context.fillStyle = this.fontColor;
            context.font = this.font;
            context.fillText(this.text, this.x - context.measureText(this.text).width / 2, this.y + this.fontSize / 4);
        };

        function main() {

            var canvas = document.createElement("canvas");
            canvas.width = 1024;
            canvas.height = 768;
            var context = canvas.getContext("2d");
            document.body.appendChild(canvas);

            init();

            var tiles;
            var dragIndex, isDragging;
            var mouseX, mouseY;
            var dragHoldX, dragHoldY;
            var timer;
            var targetX, targetY;

            function init() {
                var numTiles = 25;
                var boardLetters = "GMYONIWNXGETSMZWZZLENTEGI";

                tiles = makeTiles(numTiles, boardLetters);

                drawScreen();

                canvas.addEventListener("mousedown", mouseDownListener, false);
            }

            function makeTiles(numTiles, boardLetters) {
                var i;
                var tempX, tempY;
                var tempColor;
                var red = "rgb(247,153,141)";
                var blue = "rgb(120,200,245)";
                var gray = "rgb(230, 230, 230)";
                var size = 114; // pixels
                var boardX, boardY;
                var offest = 1; // pixels

                boardX = (canvas.width - 5 * (size + offest)) / 2;
                boardY = (canvas.height - 5 * (size + offest)) - size / 10;

                tiles = [];
                for (i = 0; i < numTiles; i++) {
                    tempX = boardX + (i % 5) * (size + offest) + (size / 2);
                    tempY = boardY + (~~(i / 5) * (size + offest)) + (size / 2);

                    var rand = Math.random();
                    tempColor = rand < 0.33 ? red : rand < 0.66 ? blue : gray;

                    tempShape = new Tile(boardLetters[i], tempX, tempY, size);
                    tempShape.color = tempColor;
                    tiles.push(tempShape);
                }

                return tiles;
            }

            function mouseDownListener(evt) {
                var i;

                //getting mouse position correctly 
                var bRect = canvas.getBoundingClientRect();
                mouseX = (evt.clientX - bRect.left) * (canvas.width / bRect.width);
                mouseY = (evt.clientY - bRect.top) * (canvas.height / bRect.height);

                // Find if a shape was clicked. 
                for (i = 0; i < tiles.length; i++) {
                    if (tiles[i].isNear(mouseX, mouseY)) {
                        isDragging = true;
                        //the following variable will be reset if this loop repeats with another successful hit:
                        dragIndex = i;
                    }
                }

                if (isDragging) {
                    window.addEventListener("mousemove", mouseMoveListener, false);

                    //place currently dragged shape on top
                    tiles.push(tiles.splice(dragIndex, 1)[0]);

                    //shapeto drag is now last one in array
                    dragHoldX = mouseX - tiles[tiles.length - 1].x;
                    dragHoldY = mouseY - tiles[tiles.length - 1].y;

                    //The "target" position is where the object should be if it were to move there instantaneously. But we will
                    //set up the code so that this target position is approached gradually, producing a smooth motion.
                    targetX = mouseX - dragHoldX;
                    targetY = mouseY - dragHoldY;

                    //start timer
                    timer = setInterval(onTimerTick, 1000 / 60);
                }
                canvas.removeEventListener("mousedown", mouseDownListener, false);
                window.addEventListener("mouseup", mouseUpListener, false);

                // Prevents the mouse down from having an effect on the main browser window:
                evt.preventDefault();
            }

            function onTimerTick() {
                var easeAmount = 0.2;
                //because of reordering, the dragging shape is the last one in the array.
                var topTile = tiles[tiles.length - 1];
                topTile.x = topTile.x + easeAmount * (targetX - topTile.x);
                topTile.y = topTile.y + easeAmount * (targetY - topTile.y);

                //stop the timer when the target position is reached (close enough)
                if ((!isDragging) && (Math.abs(topTile.x - targetX) < 0.1) && (Math.abs(topTile.y - targetY) < 0.1)) {
                    topTile.x = targetX;
                    topTile.y = targetY;
                    //stop timer:
                    clearInterval(timer);
                }
                drawScreen();
            }

            function mouseUpListener(evt) {
                canvas.addEventListener("mousedown", mouseDownListener, false);
                window.removeEventListener("mouseup", mouseUpListener, false);
                if (isDragging) {
                    isDragging = false;
                    targetX = tiles[tiles.length - 1].initalX;
                    targetY = tiles[tiles.length - 1].initalY;
                    window.removeEventListener("mousemove", mouseMoveListener, false);
                }
            }

            function mouseMoveListener(evt) {
                var posX;
                var posY;
                var shapeRad = tiles[tiles.length - 1].radius;
                var minX = shapeRad;
                var maxX = canvas.width - shapeRad;
                var minY = shapeRad;
                var maxY = canvas.height - shapeRad;

                //getting mouse position correctly 
                var bRect = canvas.getBoundingClientRect();
                mouseX = (evt.clientX - bRect.left) * (canvas.width / bRect.width);
                mouseY = (evt.clientY - bRect.top) * (canvas.height / bRect.height);

                //clamp x and y positions to prevent object from dragging outside of canvas
                posX = mouseX - dragHoldX;
                posX = (posX < minX) ? minX : ((posX > maxX) ? maxX : posX);
                posY = mouseY - dragHoldY;
                posY = (posY < minY) ? minY : ((posY > maxY) ? maxY : posY);

                targetX = posX;
                targetY = posY;
            }

            function drawShapes() {
                var i;
                for (i = 0; i < tiles.length; i++) {
                    //the drawing of the shape is handled by a function inside the external class.
                    //we must pass as an argument the context to which we are drawing the shape.
                    tiles[i].draw(context);
                }
            }

            function drawScreen() {
                context.fillStyle = 'rgb(240, 239, 236)';
                context.fillRect(0, 0, canvas.width, canvas.height);

                drawShapes();
            }

        }
    </script>

</head>

<body>
</body>

</html>
