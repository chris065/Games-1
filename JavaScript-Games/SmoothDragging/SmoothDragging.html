<!doctype html>
<html>

<head>
    <script>
        window.addEventListener("load", canvasApp, false);

        function canvasApp() {

            var canvas = document.createElement("canvas");
            canvas.width = canvas.height = 500;
            var context = canvas.getContext("2d");
            document.body.appendChild(canvas);

            init();

            var shapes;
            var dragIndex, dragging;
            var dragHoldX, dragHoldY;
            var timer;
            var mousePos;
            var targetPos;

            function init() {
                var numShapes = 10;
                shapes = makeShapes(numShapes);
                drawScreen();
                canvas.addEventListener("mousedown", mouseDownListener, false);
            }

            function makeShapes(numShapes) {
                var i;
                var tempX, tempY;
                var tempRad;
                var r1, g1, b1, color1;
                var r2, g2, b2, color2;
                var tempGrad;
                var gradFactor = 2;

                shapes = [];
                for (i = 0; i < numShapes; i++) {
                    tempRad = 5 + Math.floor(Math.random() * 20);
                    //randomized position
                    tempX = Math.random() * (canvas.width - tempRad);
                    tempY = Math.random() * (canvas.height - tempRad);

                    //Randomize the color gradient. We will select a random color and set the center of the gradient to white.
                    //We will only allow the color components to be as large as 200 (rather than the max 255) to create darker colors.
                    r1 = Math.floor(Math.random() * 200);
                    g1 = Math.floor(Math.random() * 200);
                    b1 = Math.floor(Math.random() * 200);
                    color1 = "rgb(" + r1 + "," + g1 + "," + b1 + ")";

                    r2 = Math.min(Math.floor(gradFactor * r1), 255);
                    g2 = Math.min(Math.floor(gradFactor * g1), 255);
                    b2 = Math.min(Math.floor(gradFactor * b1), 255);
                    color2 = "rgb(" + r2 + "," + g2 + "," + b2 + ")";

                    tempShape = {
                        x: tempX,
                        y: tempY,
                        rad: tempRad,
                        gradColor1: color1,
                        gradColor2: color2
                    };
                    shapes.push(tempShape);
                }

                return shapes;
            }

            function getMousePos(canvas, evt) {
                var bRect = canvas.getBoundingClientRect();
                return {
                    x: (evt.clientX - bRect.left) * (canvas.width / bRect.width),
                    y: (evt.clientY - bRect.top) * (canvas.height / bRect.height)
                };
            }

            function mouseDownListener(evt) {
                var i;
                mousePos = getMousePos(canvas, evt);

                //find which shape was clicked
                for (i = 0; i < shapes.length; i++) {
                    if (isInside(shapes[i], mousePos.x, mousePos.y)) {
                        dragging = true;
                        // the next variable will be overwritten if the loop finds another successful hit,
                        // to ensure only the topmost shape is dragged
                        dragIndex = i;
                    }
                }

                if (dragging) {
                    window.addEventListener("mousemove", mouseMoveListener, false);

                    // We now place the currently dragged shape on top by placing it last in the array.
                    shapes.push(shapes.splice(dragIndex, 1)[0]);

                    //shape to drag is now last one in array. We record the point on this object where the mouse is "holding" it:
                    dragHoldX = mousePos.x - shapes[shapes.length - 1].x;
                    dragHoldY = mousePos.y - shapes[shapes.length - 1].y;

                    // The "target" position is where the object should be if it were to move there instantaneously. But we will
                    // set up the code so that this target position is approached gradually, producing a smooth motion.        
                    targetPos = {
                        x: mousePos.x - dragHoldX,
                        y: mousePos.y - dragHoldY
                    };

                    //start timer
                    timer = setInterval(onTimerTick, 1000 / 30);
                }
                canvas.removeEventListener("mousedown", mouseDownListener, false);
                window.addEventListener("mouseup", mouseUpListener, false);

                //code below prevents the mouse down from having an effect on the main browser window:
                if (evt.preventDefault) {
                    evt.preventDefault();
                } //standard
                else if (evt.returnValue) {
                    evt.returnValue = false;
                } //older IE
                return false;
            }

            function onTimerTick() {

                // The amount to move towards the target position (between 0 and 1).
                var easeAmount = 0.20;
                // The moving shape which is the last in the array
                var lastShape = shapes[shapes.length - 1];
                // The target position is set by the mouse position as it is dragging.
                lastShape.x = lastShape.x + easeAmount * (targetPos.x - lastShape.x);
                lastShape.y = lastShape.y + easeAmount * (targetPos.y - lastShape.y);

                //stop the timer when the target position is reached (close enough)
                if ((!dragging) && (Math.abs(lastShape.x - targetPos.x) < 0.1) && (Math.abs(lastShape.y - targetPos.y) < 0.1)) {
                    lastShape.x = targetPos.x;
                    lastShape.y = targetPos.y;
                    //stop timer:
                    clearInterval(timer);
                }
                drawScreen();
            }

            function mouseUpListener(evt) {
                canvas.addEventListener("mousedown", mouseDownListener, false);
                window.removeEventListener("mouseup", mouseUpListener, false);
                if (dragging) {
                    dragging = false;
                    window.removeEventListener("mousemove", mouseMoveListener, false);
                }
            }

            function mouseMoveListener(evt) {
                var posX;
                var posY;
                var shapeRad = shapes[shapes.length - 1].rad;
                var minX = shapeRad;
                var maxX = canvas.width - shapeRad;
                var minY = shapeRad;
                var maxY = canvas.height - shapeRad;
                //getting mouse position correctly 
                mousePos = getMousePos(canvas, evt);

                //clamp x and y positions to prevent object from dragging outside of canvas
                posX = mousePos.x - dragHoldX;
                posX = (posX < minX) ? minX : ((posX > maxX) ? maxX : posX);
                posY = mousePos.y - dragHoldY;
                posY = (posY < minY) ? minY : ((posY > maxY) ? maxY : posY);

                targetPos.x = posX;
                targetPos.y = posY;
            }

            function isInside(shape, mx, my) {
                var dx, dy;
                dx = mx - shape.x;
                dy = my - shape.y;
                return (dx * dx + dy * dy < shape.rad * shape.rad);
            }

            function drawShapes() {
                var i;
                var grad;
                var x;
                var y;
                var rad;
                for (i = 0; i < shapes.length; i++) {
                    //define gradient
                    rad = shapes[i].rad;
                    x = shapes[i].x;
                    y = shapes[i].y;
                    grad = context.createRadialGradient(x - 0.33 * rad, y - 0.33 * rad, 0, x - 0.33 * rad, y - 0.33 * rad, 1.33 * rad);
                    grad.addColorStop(0, shapes[i].gradColor2);
                    grad.addColorStop(1, shapes[i].gradColor1);

                    context.fillStyle = grad;
                    context.beginPath();
                    context.arc(x, y, rad, 0, 2 * Math.PI, false);
                    context.closePath();
                    context.fill();
                }
            }

            function drawScreen() {
                var bgColor = "#000000";
                context.fillStyle = bgColor;
                context.fillRect(0, 0, canvas.width, canvas.height);
                drawShapes();
            }
        }
    </script>

</head>

<body>
</body>

</html>
