<!doctype html>
<html>

<head>
    <script>
        window.addEventListener("load", canvasApp, false);

        function canvasApp() {

            var canvas = document.createElement("canvas");
            canvas.width = canvas.height = 500;
            var context = canvas.getContext("2d");
            document.body.appendChild(canvas);

            init();

            var shapes;
            var dragIndex;
            var dragging;
            var mouseX;
            var mouseY;
            var dragHoldX;
            var dragHoldY;
            var timer;
            var targetX;
            var targetY;
            var easeAmount;
            var bgColor;

            function init() {
                var numShapes = 10;
                easeAmount = 0.20;

                bgColor = "#000000";

                shapes = [];

                makeShapes(numShapes);

                drawScreen();

                canvas.addEventListener("mousedown", mouseDownListener, false);
            }

            function makeShapes(numShapes) {
                var i;
                var tempX;
                var tempY;
                var tempRad;
                var r1;
                var g1;
                var b1;
                var color1;
                var r2;
                var g2;
                var b2;
                var color2;
                var tempGrad;
                var gradFactor = 2;
                for (i = 0; i < numShapes; i++) {
                    tempRad = 5 + Math.floor(Math.random() * 20);
                    //randomized position
                    tempX = Math.random() * (canvas.width - tempRad);
                    tempY = Math.random() * (canvas.height - tempRad);

                    //Randomize the color gradient. We will select a random color and set the center of the gradient to white.
                    //We will only allow the color components to be as large as 200 (rather than the max 255) to create darker colors.
                    r1 = Math.floor(Math.random() * 200);
                    g1 = Math.floor(Math.random() * 200);
                    b1 = Math.floor(Math.random() * 200);
                    color1 = "rgb(" + r1 + "," + g1 + "," + b1 + ")";

                    r2 = Math.min(Math.floor(gradFactor * r1), 255);
                    g2 = Math.min(Math.floor(gradFactor * g1), 255);
                    b2 = Math.min(Math.floor(gradFactor * b1), 255);
                    color2 = "rgb(" + r2 + "," + g2 + "," + b2 + ")";

                    tempShape = {
                        x: tempX,
                        y: tempY,
                        rad: tempRad,
                        gradColor1: color1,
                        gradColor2: color2
                    };
                    shapes.push(tempShape);
                }
            }

            function mouseDownListener(evt) {
                var i;

                //getting mouse position correctly 
                var bRect = canvas.getBoundingClientRect();
                mouseX = (evt.clientX - bRect.left) * (canvas.width / bRect.width);
                mouseY = (evt.clientY - bRect.top) * (canvas.height / bRect.height);

                //find which shape was clicked
                for (i = 0; i < shapes.length; i++) {
                    if (hitTest(shapes[i], mouseX, mouseY)) {
                        dragging = true;
                        //the following variable will be reset if this loop repeats with another successful hit:
                        dragIndex = i;
                    }
                }

                if (dragging) {
                    window.addEventListener("mousemove", mouseMoveListener, false);

                    //We now place the currently dragged shape on top by reordering the array which holds these objects.
                    //We 'splice' out this array element, then 'push' it back into the array at the end.
                    shapes.push(shapes.splice(dragIndex, 1)[0]);

                    //shape to drag is now last one in array. We read record the point on this object where the mouse is "holding" it:
                    dragHoldX = mouseX - shapes[shapes.length - 1].x;
                    dragHoldY = mouseY - shapes[shapes.length - 1].y;

                    //The "target" position is where the object should be if it were to move there instantaneously. But we will
                    //set up the code so that this target position is approached gradually, producing a smooth motion.
                    targetX = mouseX - dragHoldX;
                    targetY = mouseY - dragHoldY;

                    //start timer
                    timer = setInterval(onTimerTick, 1000 / 30);
                }
                canvas.removeEventListener("mousedown", mouseDownListener, false);
                window.addEventListener("mouseup", mouseUpListener, false);

                //code below prevents the mouse down from having an effect on the main browser window:
                if (evt.preventDefault) {
                    evt.preventDefault();
                } //standard
                else if (evt.returnValue) {
                    evt.returnValue = false;
                } //older IE
                return false;
            }

            function onTimerTick() {
                /*
		Because of reordering, the dragging shape is the last one in the array.
		The code below moves this shape only a portion of the distance towards the current "target" position, and 
		because this code is being executed inside a function called by a timer, the object will continue to
		move closer and closer to the target position.
		The amount to move towards the target position is set in the parameter 'easeAmount', which should range between
		0 and 1. The target position is set by the mouse position as it is dragging.		
		*/
                var lastShape = shapes[shapes.length - 1];
                lastShape.x = lastShape.x + easeAmount * (targetX - lastShape.x);
                lastShape.y = lastShape.y + easeAmount * (targetY - lastShape.y);

                //stop the timer when the target position is reached (close enough)
                if ((!dragging) && (Math.abs(lastShape.x - targetX) < 0.1) && (Math.abs(lastShape.y - targetY) < 0.1)) {
                    lastShape.x = targetX;
                    lastShape.y = targetY;
                    //stop timer:
                    clearInterval(timer);
                }
                drawScreen();
            }

            function mouseUpListener(evt) {
                canvas.addEventListener("mousedown", mouseDownListener, false);
                window.removeEventListener("mouseup", mouseUpListener, false);
                if (dragging) {
                    dragging = false;
                    window.removeEventListener("mousemove", mouseMoveListener, false);
                }
            }

            function mouseMoveListener(evt) {
                var posX;
                var posY;
                var shapeRad = shapes[shapes.length - 1].rad;
                var minX = shapeRad;
                var maxX = canvas.width - shapeRad;
                var minY = shapeRad;
                var maxY = canvas.height - shapeRad;
                //getting mouse position correctly 
                var bRect = canvas.getBoundingClientRect();
                mouseX = (evt.clientX - bRect.left) * (canvas.width / bRect.width);
                mouseY = (evt.clientY - bRect.top) * (canvas.height / bRect.height);

                //clamp x and y positions to prevent object from dragging outside of canvas
                posX = mouseX - dragHoldX;
                posX = (posX < minX) ? minX : ((posX > maxX) ? maxX : posX);
                posY = mouseY - dragHoldY;
                posY = (posY < minY) ? minY : ((posY > maxY) ? maxY : posY);

                targetX = posX;
                targetY = posY;
            }

            function hitTest(shape, mx, my) {

                var dx;
                var dy;
                dx = mx - shape.x;
                dy = my - shape.y;

                return (dx * dx + dy * dy < shape.rad * shape.rad);
            }

            function drawShapes() {
                var i;
                var grad;
                var x;
                var y;
                var rad;
                for (i = 0; i < shapes.length; i++) {
                    //define gradient
                    rad = shapes[i].rad;
                    x = shapes[i].x;
                    y = shapes[i].y;
                    grad = context.createRadialGradient(x - 0.33 * rad, y - 0.33 * rad, 0, x - 0.33 * rad, y - 0.33 * rad, 1.33 * rad);
                    grad.addColorStop(0, shapes[i].gradColor2);
                    grad.addColorStop(1, shapes[i].gradColor1);

                    context.fillStyle = grad;
                    context.beginPath();
                    context.arc(x, y, rad, 0, 2 * Math.PI, false);
                    context.closePath();
                    context.fill();
                }
            }

            function drawScreen() {
                //bg
                context.fillStyle = bgColor;
                context.fillRect(0, 0, canvas.width, canvas.height);

                drawShapes();
            }
        }
    </script>

</head>

<body>
</body>

</html>
